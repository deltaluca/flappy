//all tokens, must match the nested ordering of
//tokens in daide.Tokens
%token INTEGER
%token BRA
%token KET
%token POWER
%token AMY FLT
%token CTO CVY HLD MTO SUP VIA DSB RTO BLD REM WVE
%token MBV BPR CST ESC FAR HSC NAS NMB NMR NRN NRS NSA NSC NSF NSP NST NSU NVR NYU YSC 
%token SUC BNC CUT DSR FLD NSO RET
%token NCS NEC ECS SEC SCS SWC WCS NWC
%token SPR SUM FAL AUT WIN
%token CCD DRW FRM GOF HLO HST HUH IAM LOD MAP MDF MIS NME NOT NOW OBS OFF ORD OUT PRN REJ SCO SLO SND SUB SVE THX TME YES ADM
%token AOA BTL ERR LVL MRT MTL NPB NPR PDA PTL RTL UNO DSD
%token ALY AND BWD DMZ ELS EXP FWD FCT FOR HOUW IDK IFF INS IOU OCC ORR PCE POB PPT PRP QRY SCD SRY SUG THK THN TRY UOM VSS WHT WHY XDO XOY YDO WRT
%token TEXT
%token PROVINCE

%{

import daide.Tokens;
import daide.Language;
import Type;

class TU {

	static public function text(t:Token) {
		return switch(t) { case tText(x): x; default: null; };
	}
	static public function integer(t:Token) {
		return switch(t) { case tInteger(x): x; default: -1; };
	}
	static public function power(t:Token) {
		return switch(t) { case tPower(x): x; default: -1; };
	}
	static public function province(t:Token) {
		return switch(t) { case tProvince(x): x; default: null; };
	}
	static public function coast(t:Token) {
		return switch(t) { case tCoast(x): x; default: null; };
	}
	static public function unitType(t:Token) {
		return switch(t) { case tUnitType(x): x; default: null; };
	}
	static public function phase(t:Token) {
		return switch(t) { case tPhase(x): x; default: null; };
	}

	//need a mapping [0,#tokens) in order tokens are declared
	//this is complicated due to the nesting of Token declarations
	//otherwise could have simply used Type.enumIndex(t)
	static var offsets:Array<Int> = null;
	static public function index(t:Token) {
		if(offsets==null) {
			offsets = [0,1,2,3,4];
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(UnitType).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Order).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(OrderNote).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Result).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Coast).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Phase).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Command).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Parameter).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Press).length);
			offsets.push(offsets[offsets.length-1] + 1);
		}

		var off = offsets[Type.enumIndex(t)];
		var pars = Type.enumParameters(t);
		var ind = if(pars.length==0) 0 else Type.enumIndex(pars[0]);
		if(ind==-1) ind = 0;
		return off + ind;
	}
}
 
%}

%entry message

%message
	: client_server_message %{ %0; %}
;

%client_server_message
	: NME BRA TEXT KET BRA TEXT KET %{ mName(TU.text(%2),TU.text(%5)); %}
	| OBS %{ mObserver; %}
	| IAM BRA POWER KET BRA INTEGER KET %{ mIAm(TU.power(%2),TU.integer(%5)); %}
	| MAP %{ mMap(null); %}
//	| MDF %{ mMapDefinition(nulls); %}
	| YES BRA acknowledgable_command KET %{ mAccept(%2); %}
	| REJ BRA acknowledgable_command KEY %{ mReject(%2); %}
//	| NOW %{ mCurrentLocation(nulls); %}
//	| SCO %{ mSupplyOwnership(nulls); %}
	| HST BRA turn KET %{ mHistory(%2); %}
	| TME BRA INTEGER KET %{ mTimeToDeadline(TU.integer(%2)); %}
	| TME %{ mTimeToDeadline(null); %}
	| ADM BRA TEXT KET BRA TEXT KET %{ mAdmin(TU.text(%2),TU.text(%5)); %}
//	| PRN ...?
//	| HUH ...?
	| HLO %{ mHello; %}
	| SUB order_list %{ mSubmit(null,%1); %}
	| SUB BRA turn KET order_list %{ mSubmit(%2,%4); %}
//	| NOT BRA negatable_command KET %{ ... %}		
;

%acknowedgable_command
	: MAP BRA TEXT KET %{ mMap(TU.text(%2)); %}
	| SVE BRA TEXT KET %{ mSaveGame(TU.text(%2)); %}
;

%turn
	: phase INTEGER %{ { phase : %0, turn : TU.integer(%1) }; %} 
;

%phase
	: SPR %{ TU.phase(%0); %} 
	| SUM %{ TU.phase(%0); %} 
	| FAL %{ TU.phase(%0); %} 
	| AUT %{ TU.phase(%0); %} 
	| WIN %{ TU.phase(%0); %} 
;

%coast
	: NCS %{ TU.coast(%0); %} 
	| NEC %{ TU.coast(%0); %} 
	| ECS %{ TU.coast(%0); %} 
	| SEC %{ TU.coast(%0); %} 
	| SCS %{ TU.coast(%0); %} 
	| SWC %{ TU.coast(%0); %} 
	| WCS %{ TU.coast(%0); %} 
	| NWC %{ TU.coast(%0); %} 
;

%power_list
	: POWER %{ [TU.power(%0)]; %}
	| power_list POWER %{ %0.push(TU.power(%1)); %0; %}
;

%order
	: BRA unit_with_location KET HLD %{ moHold(%1); %}
	| BRA unit_with_location KET DSB %{ moDisband(%1); %}
	| BRA unit_with_location KET BLD %{ moBuild(%1); %}
	| BRA unit_with_location KET REM %{ moRemove(%1); %}
	| BRA unit_with_location KET RTO location %{ moRetreat(%1,%4); %}
	| BRA unit_with_location KET MTO location %{ moMove(%1,%4); %}
	| BRA unit_with_location KET SUP BRA unit_with_location KET %{
		moSupport(%1,%5,null);
	%}
	| BRA unit_with_location KET SUP BRA unit_with_location KET MTO PROVINCE %{
		moSupport(%1,%5,TU.province(%8));
	%}
	| BRA unit_with_location KET CVY BRA unit_with_location KET CTO PROVINCE %{
		moConvoy(%1,%5,TU.province(%8));
	%}
	| BRA unit_with_location KET CTO PROVINCE VIA BRA province_list KET %{
		moMoveByConvoy(%1,TU.province(%4),%7);
	%}
;

%order_list
	: BRA order KET %{ [%1]; %}
	| order_list BRA order KET %{ %0.push(%2); %0; %}
;

%unit_with_location
	: POWER unit_type location %{ { power : TU.power(%0), type : %1, location : %2 }; %}
;

%location
	: PROVINCE %{ { province : TU.province(%0), coast : null }; %}
	| BRA province_and_coast KET %{ %1; %}
;

%province_and_coast
	: PROVINCE coast %{ { province : TU.province(%0), coast : %1 }; %}
;

%province_list
	: PROVINCE %{ [TU.province(%0)]; %}
	| province_list PROVINCE %{ %0.push(TU.province(%1)); %0; %}
;

%unit_type
	: AMY %{ TU.unitType(%0); %}
	| FLT %{ TU.unitType(%0); %}
;
