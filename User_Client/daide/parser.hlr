//all tokens, must match the nested ordering of
//tokens in daide.Tokens
%token INTEGER
%token BRA
%token KET
%token POWER
%token AMY FLT
%token CTO CVY HLD MTO SUP VIA DSB RTO BLD REM WVE
%token MBV BPR CST ESC FAR HSC NAS NMB NMR NRN NRS NSA NSC NSF NSP NST NSU NVR NYU YSC 
%token SUC BNC CUT DSR FLD NSO RET
%token NCS NEC ECS SEC SCS SWC WCS NWC
%token SPR SUM FAL AUT WIN
%token CCD DRW FRM GOF HLO HST HUH IAM LOD MAP MDF MIS NME NOT NOW OBS OFF ORD OUT PRN REJ SCO SLO SND SUB SVE THX TME YES ADM
%token AOA BTL ERR LVL MRT MTL NPB NPR PDA PTL RTL UNO DSD
%token ALY AND BWD DMZ ELS EXP FWD FCT FOR HOUW IDK IFF INS IOU OCC ORR PCE POB PPT PRP QRY SCD SRY SUG THK THN TRY UOM VSS WHT WHY XDO XOY YDO WRT
%token TEXT
%token PROVINCE

%{

import daide.Tokens;
import daide.Language;

class TU {

	static public function text(t:Token) {
		return switch(t) { case tText(x): x; default: null; };
	}
	static public function integer(t:Token) {
		return switch(t) { case tInteger(x): x; default: -1; };
	}
	static public function power(t:Token) {
		return switch(t) { case tPower(x): x; default: -1; };
	}

	//need a one-one mapping in order tokens are declared
	//to each possible token.

	//this is complicated due to the nesting of Token declarations
	//but these should be computed at compile time by haxe
	static public function index(t:Token) {
		return switch(t) {
			case tInteger(_): 0;
			case tLeftParen:  1;
			case tRightParen: 2;
			case tPower(_):   3;
			case tUnitType(x):
				4 + Type.enumIndex(x);
			case tOrder(x):
				4 + Type.getEnumConstructs(UnitType).length
				  + Type.enumIndex(x);
			case tOrderNote(x):
				4 + Type.getEnumConstructs(UnitType).length
				  + Type.getEnumConstructs(Order).length
				  + Type.enumIndex(x);
			case tResult(x):
				4 + Type.getEnumConstructs(UnitType).length
				  + Type.getEnumConstructs(Order).length
				  + Type.getEnumConstructs(OrderNote).length
				  + Type.enumIndex(x);
			case tCoast(x):
				4 + Type.getEnumConstructs(UnitType).length
				  + Type.getEnumConstructs(Order).length
				  + Type.getEnumConstructs(OrderNote).length
				  + Type.getEnumConstructs(Result).length
				  + Type.enumIndex(x);
			case tPhase(x):
				4 + Type.getEnumConstructs(UnitType).length
				  + Type.getEnumConstructs(Order).length
				  + Type.getEnumConstructs(OrderNote).length
				  + Type.getEnumConstructs(Result).length
				  + Type.getEnumConstructs(Coast).length
				  + Type.enumIndex(x);
			case tCommand(x):
				4 + Type.getEnumConstructs(UnitType).length
				  + Type.getEnumConstructs(Order).length
				  + Type.getEnumConstructs(OrderNote).length
				  + Type.getEnumConstructs(Result).length
				  + Type.getEnumConstructs(Coast).length
				  + Type.getEnumConstructs(Phase).length
				  + Type.enumIndex(x);
			case tParameter(x):
				4 + Type.getEnumConstructs(UnitType).length
				  + Type.getEnumConstructs(Order).length
				  + Type.getEnumConstructs(OrderNote).length
				  + Type.getEnumConstructs(Result).length
				  + Type.getEnumConstructs(Coast).length
				  + Type.getEnumConstructs(Phase).length
				  + Type.getEnumConstructs(Command).length
				  + Type.enumIndex(x);
			case tPress(x):
				4 + Type.getEnumConstructs(UnitType).length
				  + Type.getEnumConstructs(Order).length
				  + Type.getEnumConstructs(OrderNote).length
				  + Type.getEnumConstructs(Result).length
				  + Type.getEnumConstructs(Coast).length
				  + Type.getEnumConstructs(Phase).length
				  + Type.getEnumConstructs(Command).length
				  + Type.getEnumConstructs(Parameter).length
				  + Type.enumIndex(x);
			case tText(_):
				4 + Type.getEnumConstructs(UnitType).length
				  + Type.getEnumConstructs(Order).length
				  + Type.getEnumConstructs(OrderNote).length
				  + Type.getEnumConstructs(Result).length
				  + Type.getEnumConstructs(Coast).length
				  + Type.getEnumConstructs(Phase).length
				  + Type.getEnumConstructs(Command).length
				  + Type.getEnumConstructs(Parameter).length
				  + Type.getEnumConstructs(Press).length;
			case tProvince(_):
				4 + Type.getEnumConstructs(UnitType).length
				  + Type.getEnumConstructs(Order).length
				  + Type.getEnumConstructs(OrderNote).length
				  + Type.getEnumConstructs(Result).length
				  + Type.getEnumConstructs(Phase).length
				  + Type.getEnumConstructs(Command).length
				  + Type.getEnumConstructs(Parameter).length
				  + Type.getEnumConstructs(Coast).length
				  + Type.getEnumConstructs(Press).length
				  + 1;
		}
	}
}
 
%}

%entry message

%message
	: client_server_message %{ %0; %}
;

%client_server_message
// level OBS
	: NME BRA TEXT KET BRA TEXT KET %{ mObs(obsName(TU.text(%2),TU.text(%5))); %}
	| OBS %{ mObs(obsObserver); %}
	| IAM BRA POWER KET BRA INTEGER KET %{ mObs(obsIAm(TU.power(%2),TU.integer(%5))); %}
	| MAP %{ mObs(obsMap_0); %}
	| MDF %{ mObs(obsMapDefinition_0); %}
	| YES BRA acknowedgable_command KET %{ mObs(obsAccept(%2)); %}
	| REJ BRA acknowedgable_command KET %{ mObs(obsReject(%2)); %}
	| NOW %{ mObs(obsCurrentPosition_0); %}
	| SCO %{ mObs(obsSupplyOwnership_0); %}
	| HST BRA turn KET %{ mObs(obsHistory(%2)); %}
	| TME BRA INTEGER KET %{ mObs(obsTimeToDeadline(TU.integer(%2))); %}
	| TME %{ mObs(obsTimeToDeadline_0); %}
	| ADM BRA TEXT KET BRA TEXT KET %{ mObs(obsAdmin(TU.text(%2),TU.text(%5))); %}
//	| PRN...
//	| HUH...
// level 0
	| HLO %{ mLvl0(lvl0Hello_0); %}
	| SUB order_list %{ mLvl0(lvl0Submit(null,%1)); %}
	| SUB BRA turn KET order_list %{ mLvl0(lvl0Submit(%2,%4)); %}
	| NOT BRA negatable_command KET %{ mLvl0(lvl0Not(%2)); %}
	| MIS %{ mLvl0(lvl0MissingOrders_0); %}
	| GOF %{ mLvl0(lvl0GoFlag_0); %}
	| ORD %{ mLvl0(lvl0OrderResult_0); %}
	| DRW %{ mLvl0(lvl0Draw_0); %}
// level 10
	| DRW BRA POWER power_list KET %{ %3.unshift(TU.power(%2)); mLvl10(lvl10Draw(%3)); %}
//	| send_message %{ %0; %}
;

%acknowedgable_command
	: MAP BRA TEXT KET %{ mObs(obsMap(TU.text(%2))); %}
	| SVE BRA TEXT KET %{ mObs(obsSaveGame(TU.text(%2))); %}
;

%negatable_command
	: GOF %{ mObs(obsGoFlag_0); %}
	| DRW %{ mObs(obsDraw_0); %}
	| DRW BRA POWER power_list KET %{ %3.unshift(TU.power(%2)); mObs(obsDraw(%3)); %}
	| TME %{ mObs(obsTimeToDeadline_0); %}
	| TME BRA INTEGER KET %{ mObs(obsTimeToDeadline(TU.integer(%2))); %}
	| SUB %{ mObs(obsSubmit_0); %}
	| SUB BRA order KET %{ mObs(obsSubmit(%2)); %}
;

%turn
	: phase INTEGER %{ { phase : %0, turn : TU.integer(%1) }; %} 
;

%phase
	: SPR %{ %0; %} 
	| SUM %{ %0; %} 
	| FAL %{ %0; %} 
	| AUT %{ %0; %} 
	| WIN %{ %0; %} 
;

%power_list
	: POWER %{ [TU.power(%0)]; %}
	| power_list POWER %{ %0.push(TU.power(%1)); %0; %}
;

%order
	: BRA unit_with_location KET HLD %{ roHold(%1); %}
	| BRA unit_with_location KET DSB %{ roDisband(%1); %}
	| BRA unit_with_location KET BLD %{ roBuild(%1); %}
	| BRA unit_with_location KET REM %{ roRemove(%1); %}
;

%order_list
	: BRA order KET %{ [%1]; %}
	| order_list BRA order KET %{ %0.push(%2); %0; %}
;

%unit_with_location
	: POWER unit_type PROVINCE %{ { power : TU.power(%0), type : %1, location : { province : %2, coast : null } }; %}
	| POWER unit_type BRA province_and_coast KET %{ { power : TU.power(%0), type : %1, location : %3 }; %}
;

%province_and_coast
	: PROVINCE COAST %{ { province : %0, coast : %1 }; %}
;

%unit_type
	: AMY %{ %0; %}
	| FLT %{ %0; %}
;

%variant
	: BRA variant_option KET %{ [%1]; %}
	| variant BRA variant_option KET %{ %0.push(%2); %0; %}
;

%variant_option
	: LVL INTEGER %{ { par : %0, val : TU.integer(%1) }; %}
	| MTL INTEGER %{ { par : %0, val : TU.integer(%1) }; %}
	| RTL INTEGER %{ { par : %0, val : TU.integer(%1) }; %}
	| BTL INTEGER %{ { par : %0, val : TU.integer(%1) }; %}
	| AOA         %{ { par : %0, val : null           }; %}
	| DSD         %{ { par : %0, val : null           }; %}
	| PDA         %{ { par : %0, val : null           }; %}
	| PTL INTEGER %{ { par : %0, val : TU.integer(%1) }; %}
	| NPR         %{ { par : %0, val : null           }; %}
	| NPB         %{ { par : %0, val : null           }; %}
;

