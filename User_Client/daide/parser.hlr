//all tokens, must match the nested ordering of
//tokens in daide.Tokens
%token INTEGER
%token BRA
%token KET
%token POWER
%token AMY FLT
%token CTO CVY HLD MTO SUP VIA DSB RTO BLD REM WVE
%token MBV BPR CST ESC FAR HSC NAS NMB NMR NRN NRS NSA NSC NSF NSP NST NSU NVR NYU YSC 
%token SUC BNC CUT DSR FLD NSO RET
%token NCS NEC ECS SEC SCS SWC WCS NWC
%token SPR SUM FAL AUT WIN
%token CCD DRW FRM GOF HLO HST HUH IAM LOD MAP MDF MIS NME NOT NOW OBS OFF ORD OUT PRN REJ SCO SLO SND SUB SVE THX TME YES ADM
%token AOA BTL ERR LVL MRT MTL NPB NPR PDA PTL RTL UNO DSD
%token ALY AND BWD DMZ ELS EXP FWD FCT FOR HOW IDK IFF INS IOU OCC ORR PCE POB PPT PRP QRY SCD SRY SUG THK THN TRY UOM VSS WHT WHY XDO XOY YDO WRT
%token TEXT
%token INLAND SEA COASTAL BICOASTAL

%{

import daide.Tokens;
import daide.Language;
import Type;

class TU {

	static public function text(t:Token) {
		return switch(t) { case tText(x): x; default: null; };
	}
	static public function integer(t:Token) {
		return switch(t) { case tInteger(x): x; default: -1; };
	}
	static public function power(t:Token) {
		return switch(t) { case tPower(x): x; default: -1; };
	}
	static public function province(t:Token) {
		return switch(t) { case tProvince(x): x; default: null; };
	}
	static public function coast(t:Token) {
		return switch(t) { case tCoast(x): x; default: null; };
	}
	static public function unitType(t:Token) {
		return switch(t) { case tUnitType(x): x; default: null; };
	}
	static public function phase(t:Token) {
		return switch(t) { case tPhase(x): x; default: null; };
	}
	static public function parameter(t:Token) {
		return switch(t) { case tParameter(x): x; default: null; };
	}

	//need a mapping [0,#tokens) in order tokens are declared
	//this is complicated due to the nesting of Token declarations
	//otherwise could have simply used Type.enumIndex(t)
	static var offsets:Array<Int> = null;
	static public function index(t:Token) {
		if(offsets==null) {
			offsets = [0,1,2,3,4];
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(UnitType).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Order).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(OrderNote).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Result).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Coast).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Phase).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Command).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Parameter).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Press).length);
			offsets.push(offsets[offsets.length-1] + 1);
		}

		var off = offsets[Type.enumIndex(t)];
		var pars = Type.enumParameters(t);
		var ind = if(pars.length==0) 0 else Type.enumIndex(pars[0]);
		if(ind==-1) ind = 0;
		return off + ind;
	}
}
 
%}

%entry message

// Message
%message
	: client_server_message
	| server_client_message
;

// Message
%client_server_message
	: NME BRA TEXT KET BRA TEXT KET %{ mName(TU.text(%2),TU.text(%5)); %}
	| OBS %{ mObserver; %}
	| IAM BRA POWER KET BRA INTEGER KET %{ mIAm(TU.power(%2),TU.integer(%5)); %}
	| MAP %{ mMap(null); %}
	| MDF %{ mMapDefinition(null,null,null); %}
	| YES BRA acknowledgable_command KET %{ mAccept(%2); %}
	| REJ BRA acknowledgable_command KEY %{ mReject(%2); %}
	| NOW %{ mCurrentLocation(null,null); %}
	| SCO %{ mSupplyOwnership(null); %}
	| HST BRA turn KET %{ mHistory(%2); %}
	| TME BRA INTEGER KET %{ mTimeToDeadline(TU.integer(%2)); %}
	| TME %{ mTimeToDeadline(null); %}
	| ADM BRA TEXT KET BRA TEXT KET %{ mAdmin(TU.text(%2),TU.text(%5)); %}
	| PRN BRA bad_bracketed_sequence KET %{ mBadBrackets(%2); %}
	| HUH BRA any_token_sequence KET %{ mHuh(%2); %}
	| HLO %{ mHello(null,null,null); %}
	| SUB order_list %{ mSubmit(null,%1); %}
	| SUB BRA turn KET order_list %{ mSubmit(%2,%4); %}
//	| NOT BRA negatable_command KET %{ ... %}		
//	| MIS
//	| GOF
//	| ORD
	| DRW %{ mDraw(null); %}
	| DRW BRA POWER power_list KET %{ %3.unshift(TU.power(%2)); mDraw(%3); %}
//	| send_message %{ %0; %}
;

// Message
%server_client_message
//	: YES 
//	| YES
//	| REJ
//	| REJ
	: MAP BRA TEXT KET %{ mMap(TU.text(%2)); %}
	| MDF BRA power_list KET BRA mdf_provinces KET BRA mdf_adjacencies KET %{ mMapDefinition(%2,%5,%8); %}
	| HLO BRA POWER KET BRA INTEGER KET BRA variant KET %{ mHello(TU.power(%2),TU.integer(%5),%8); %}
	| NOW BRA turn KET unit_with_location_and_mrt_list %{ mCurrentLocation(%2,%4); %}
	| SCO sco_entry_list %{ mSupplyOwnership(%1); %}
//	| THX
//	| MIS
//	| MIS
//	| ORD
	| SVE BRA TEXT KET %{ mSaveGame(TU.text(%2)); %}
	| LOD BRA TEXT KET %{ mLoadGame(TU.text(%2)); %}
//	| OFF
	| TME BRA INTEGER KET %{ mTimeToDeadline(TU.integer(%2)); %}
	| PRN BRA bad_bracketed_sequence KET %{ mBadBrackets(%2); %}
	| HUH BRA any_token_sequence KET %{ mHuh(%2); %}
//	| CCD
//	| NOT
	| ADM BRA TEXT KET BRA TEXT KET %{ mAdmin(TU.text(%2),TU.text(%5)); %}
//	| SLO
	| DRW %{ mDraw(null); %}
//	| OUT
	| DRW BRA POWER power_list KET %{ %3.unshift(TU.power(%2)); mDraw(%3); %}
//	| FRM
//	| FRM
;

// Message
%acknowedgable_command
	: MAP BRA TEXT KET %{ mMap(TU.text(%2)); %}
	| SVE BRA TEXT KET %{ mSaveGame(TU.text(%2)); %}
;

// Array<Token>
%any_token_sequence
	: any_no_braket %{ [%0]; %}
	| BRA any_token_sequence KET %{ %1.unshift(%0); %1.push(%2); %1; %}
	| any_token_sequence any_no_bracket %{ %0.push(%1); %0; %}
	| any_token_sequence BRA any_token_sequence KET %{ %0.push(%1); %0 = %0.concat(%2); %0.push(%3); %0; %}
;

%any_no_bracket : INTEGER | POWER | AMY | FLT | CTO | CVY | HLD | MTO | SUP | VIA | DSB | RTO | BLD | REM | WVE | MBV | BPR | CST | ESC | FAR | HSC | NAS | NMB | NMR | NRN | NRS | NSA | NSC | NSF | NSP | NST | NSU | NVR | NYU | YSC | SUC | BNC | CUT | DSR | FLD | NSO | RET | NCS | NEC | ECS | SEC | SCS | SWC | WCS | NWC | SPR | SUM | FAL | AUT | WIN | CCD | DRW | FRM | GOF | HLO | HST | HUH | IAM | LOD | MAP | MDF | MIS | NME | NOT | NOW | OBS | OFF | ORD | OUT | PRN | REJ | SCO | SLO | SND | SUB | SVE | THX | TME | YES | ADM | AOA | BTL | ERR | LVL | MRT | MTL | NPB | NPR | PDA | PTL | RTL | UNO | DSD | ALY | AND | BWD | DMZ | ELS | EXP | FWD | FCT | FOR | HOW | IDK | IFF | INS | IOU | OCC | ORR | PCE | POB | PPT | PRP | QRY | SCD | SRY | SUG | THK | THN | TRY | UOM | VSS | WHT | WHY | XDO | XOY | YDO | WRT | TEXT | INLAND | SEA | COASTAL | BICOASTAL ;

%any : any_no_bracket | BRA | KET ;

// Array<Token>
%bad_bracketed_sequence
	: any %{ [%0]; %}
	| bad_bracketed_sequence any %{ %0.push(%1); %0; %}
;

// Coast
%coast
	: NCS %{ TU.coast(%0); %} 
	| NEC %{ TU.coast(%0); %} 
	| ECS %{ TU.coast(%0); %} 
	| SEC %{ TU.coast(%0); %} 
	| SCS %{ TU.coast(%0); %} 
	| SWC %{ TU.coast(%0); %} 
	| WCS %{ TU.coast(%0); %} 
	| NWC %{ TU.coast(%0); %} 
;

// ScoEntry
%sco_entry
	: POWER province_list %{ { power : TU.power(%0), locs : %1 }; %}
;

// Array<ScoEntry>
%sco_entry_list
	: BRA sco_entry KET %{ [%1]; %}
	| sco_entry_list BRA sco_entry KET %{ %0.push(%2); %0; %}
;

// Turn
%turn
	: phase INTEGER %{ { phase : %0, turn : TU.integer(%1) }; %} 
;

// Phase
%phase
	: SPR %{ TU.phase(%0); %} 
	| SUM %{ TU.phase(%0); %} 
	| FAL %{ TU.phase(%0); %} 
	| AUT %{ TU.phase(%0); %} 
	| WIN %{ TU.phase(%0); %} 
;

// Province
%province
	: INLAND %{ TU.province(%0); %}
	| SEA %{ TU.province(%0); %}
	| COASTAL %{ TU.province(%0); %}
	| BICOASTAL %{ TU.province(%0); %}
;

// Array<Int>
%power_list
	: POWER %{ [TU.power(%0)]; %}
	| power_list POWER %{ %0.push(TU.power(%1)); %0; %}
;

// MsgOrder
%order
	: BRA unit_with_location KET HLD %{ moHold(%1); %}
	| BRA unit_with_location KET DSB %{ moDisband(%1); %}
	| BRA unit_with_location KET BLD %{ moBuild(%1); %}
	| BRA unit_with_location KET REM %{ moRemove(%1); %}
	| BRA unit_with_location KET RTO mdf_province %{ moRetreat(%1,%4); %}
	| BRA unit_with_location KET MTO mdf_province %{ moMove(%1,%4); %}
	| BRA unit_with_location KET SUP BRA unit_with_location KET %{
		moSupport(%1,%5,null);
	%}
	| BRA unit_with_location KET SUP BRA unit_with_location KET MTO province %{
		moSupport(%1,%5,%8);
	%}
	| BRA unit_with_location KET CVY BRA unit_with_location KET CTO province %{
		moConvoy(%1,%5,%8);
	%}
	| BRA unit_with_location KET CTO province VIA BRA province_list KET %{
		moMoveByConvoy(%1,%4,%7);
	%}
;

// Array<MsgOrder>
%order_list
	: BRA order KET %{ [%1]; %}
	| order_list BRA order KET %{ %0.push(%2); %0; %}
;

// UnitWithLoc
%unit_with_location
	: POWER unit_type mdf_province %{ { power : TU.power(%0), type : %1, location : %2 }; %}
;

// Array<MdfProAdjacencies>
%mdf_adjacencies
	: BRA mdf_province_adjacencies KET %{ [%1]; %}
	| mdf_provinces BRA mdf_province_adjacencies KET %{ %0.push(%2); %0; %}
;

// MdfProAdjacencies
%mdf_province_adjacencies
	: province mdf_coast_adjacencies_list %{ { pro : %0, coasts : %1 }; %}
;

// Coast
%mdf_coast
	: FLT coast %{ %1; %}
;

// MdfCoastAdjacencies
%mdf_coast_adjacencies
	: unit_type mdf_province_list %{ { unit : %0, locs : %1 }; %}
;

// Array<MdfCoastAdjacencies>
%mdf_coast_adjacencies_list
	: BRA mdf_coast_adjacencies KET %{ [%1]; %}
	| mdf_coast_adjacencies_list BRA mdf_coast_adjacencies KET %{ %0.push(%2); %0; %}
;

// MdfCentreList
%mdf_centre_list
	: POWER province_list %{ { powers: [TU.power(%0)], locs : %1 }; %}
	| UNO province_list   %{ { powers: [], locs : %1 }; %}
	| BRA power_list KET province_list %{ { powers: %1, locs : %3 }; %}
;

// Array<MdfCentreList>
%mdf_supply_centres
	: BRA mdf_centre_list KET %{ [%1]; %}
	| mdf_centre_list_list BRA mdf_centre_list KET %{ %0.push(%2); %0; %}
;

// MdfProvinces
%mdf_provinces
	: BRA mdf_supply_centres KET BRA province_list KET %{ {slocs: %2, locs : %4 }; %}
;

// Location
%mdf_province
	: province %{ { province : %0, coast : null }; %}
	| BRA province_and_coast KET %{ %1; %}
;

// Array<Location>
%mdf_province_list
	: mdf_province %{ [%0]; %}
	| mdf_province_list mdf_province %{ %0.push(%1); %0; %}
;

// Location
%province_and_coast
	: province coast %{ { province : %0, coast : %1 }; %}
;

// Array<Location>
%province_list
	: province %{ [%0]; %}
	| province_list province %{ %0.push(%1); %0; %}
;

// UnitType
%unit_type
	: AMY %{ TU.unitType(%0); %}
	| FLT %{ TU.unitType(%0); %}
;

// UnitWithLocAndMRT
%unit_with_location_and_mrt
	: unit_with_location %{ { unitloc : %0, locs : null }; %}
	| unit_with_location MRT BRA mdf_province_list KET %{ { unitloc : %0, locs : %3 }; %}
;

// Array<UnitWithLocAndMRT>
%unit_with_location_and_mrt_list
	: BRA unit_with_location_and_mrt KET %{ [%1]; %}
	| unit_with_location_and_mrt_list BRA unit_with_location_and_mrt KET %{ %0.push(%2); %0; %}
;

// Variant
%variant
	: BRA variant_option KET %{ [%1]; %}
	| variant BRA variant_option KET %{ %0.push(%2); %0; %}
;

// VariantOption
%variant_option
	: LVL INTEGER %{ { par : TU.parameter(%0), val : TU.integer(%1) }; %}
	| MTL INTEGER %{ { par : TU.parameter(%0), val : TU.integer(%1) }; %}
	| RTL INTEGER %{ { par : TU.parameter(%0), val : TU.integer(%1) }; %}
	| BTL INTEGER %{ { par : TU.parameter(%0), val : TU.integer(%1) }; %}
	| AOA         %{ { par : TU.parameter(%0), val : null           }; %}
	| DSD         %{ { par : TU.parameter(%0), val : null           }; %}
	| PDA         %{ { par : TU.parameter(%0), val : null           }; %}
	| PTL INTEGER %{ { par : TU.parameter(%0), val : TU.integer(%1) }; %}
	| NPR         %{ { par : TU.parameter(%0), val : null           }; %}
	| NPB         %{ { par : TU.parameter(%0), val : null           }; %}
;
