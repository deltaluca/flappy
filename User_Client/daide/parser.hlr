//all tokens, must match the nested ordering of
//tokens in daide.Tokens
%token INTEGER
%token BRA
%token KET
%token POWER
%token AMY FLT
%token CTO CVY HLD MTO SUP VIA DSB RTO BLD REM WVE
%token MBV BPR CST ESC FAR HSC NAS NMB NMR NRN NRS NSA NSC NSF NSP NST NSU NVR NYU YSC 
%token SUC BNC CUT DSR FLD NSO RET
%token NCS NEC ECS SEC SCS SWC WCS NWC
%token SPR SUM FAL AUT WIN
%token CCD DRW FRM GOF HLO HST HUH IAM LOD MAP MDF MIS NME NOT NOW OBS OFF ORD OUT PRN REJ SCO SLO SND SUB SVE THX TME YES ADM
%token AOA BTL ERR LVL MRT MTL NPB NPR PDA PTL RTL UNO DSD
%token ALY AND BWD DMZ ELS EXP FWD FCT FOR HOW IDK IFF INS IOU OCC ORR PCE POB PPT PRP QRY SCD SRY SUG THK THN TRY UOM VSS WHT WHY XDO XOY YDO WRT
%token TEXT
%token INLAND SEA COASTAL BICOASTAL

%{

import daide.Tokens;
import daide.Language;
import Type;

class TU {

	static public function text(t:Token) {
		return switch(t) { case tText(x): x; default: null; };
	}
	static public function integer(t:Token) {
		return switch(t) { case tInteger(x): x; default: -1; };
	}
	static public function power(t:Token) {
		return switch(t) { case tPower(x): x; default: -1; };
	}
	static public function province(t:Token) {
		return switch(t) { case tProvince(x): x; default: null; };
	}
	static public function coast(t:Token) {
		return switch(t) { case tCoast(x): x; default: null; };
	}
	static public function unitType(t:Token) {
		return switch(t) { case tUnitType(x): x; default: null; };
	}
	static public function phase(t:Token) {
		return switch(t) { case tPhase(x): x; default: null; };
	}
	static public function parameter(t:Token) {
		return switch(t) { case tParameter(x): x; default: null; };
	}

	//need a mapping [0,#tokens) in order tokens are declared
	//this is complicated due to the nesting of Token declarations
	//otherwise could have simply used Type.enumIndex(t)
	static var offsets:Array<Int> = null;
	static public function index(t:Token) {
		if(offsets==null) {
			offsets = [0,1,2,3,4];
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(UnitType).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Order).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(OrderNote).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Result).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Coast).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Phase).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Command).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Parameter).length);
			offsets.push(offsets[offsets.length-1] + Type.getEnumConstructs(Press).length);
			offsets.push(offsets[offsets.length-1] + 1);
		}

		var off = offsets[Type.enumIndex(t)];
		var pars = Type.enumParameters(t);
		var ind = if(pars.length==0) 0 else Type.enumIndex(pars[0]);
		if(ind==-1) ind = 0;
		return off + ind;
	}
}
 
%}

%entry message

// Message
%message
	: client_server_message
	| server_client_message
;

// Message
%client_server_message
	: NME BRA TEXT KET BRA TEXT KET 			%{ mName(TU.text(%2),TU.text(%5)); %}
	| OBS 										%{ mObserver; %}
	| IAM BRA POWER KET BRA INTEGER KET			%{ mIAm(TU.power(%2),TU.integer(%5)); %}
	| MAP 										%{ mMap(null); %}
	| MDF 										%{ mMapDefinition(null,null,null); %}
	| YES BRA acknowledgable_command KET 		%{ mAccept(%2); %}
	| REJ BRA acknowledgable_command KEY 		%{ mReject(%2); %}
	| NOW 										%{ mCurrentLocation(null,null); %}
	| SCO 										%{ mSupplyOwnership(null); %}
	| HST BRA turn KET 							%{ mHistory(%2); %}
	| TME BRA INTEGER KET 						%{ mTimeToDeadline(TU.integer(%2)); %}
	| TME 										%{ mTimeToDeadline(null); %}
	| ADM BRA TEXT KET BRA TEXT KET 			%{ mAdmin(TU.text(%2),TU.text(%5)); %}
	| PRN BRA bad_bracketed_sequence KET 		%{ mBadBrackets(%2); %}
	| HUH BRA any_token_sequence KET 			%{ mHuh(%2); %}
	| HLO 										%{ mHello(null,null,null); %}
	| SUB order_list 							%{ mSubmit(null,%1); %}
	| SUB BRA turn KET order_list 				%{ mSubmit(%2,%4); %}
	| NOT BRA negatable_command KET 			%{ mNOT(%2); %}		
	| MIS 										%{ mMissingOrders(null,null); %}
	| GOF 										%{ mGoFlag; %}
	| ORD 										%{ mOrderResult(null,null,null); %}
	| DRW 										%{ mDraw(null); %}
	| DRW BRA POWER power_list KET 				%{ %3.unshift(TU.power(%2)); mDraw(%3); %}
//	| send_message
;

// Message
%server_client_message
	: YES BRA client_command KET 				%{ mAccept(%2); %}
	| YES BRA client_request KET 				%{ mAccept(%2); %}
	| REJ BRA client_request KET 				%{ mReject(%2); %}
	| REJ BRA rejectable_client_command KET 	%{ mReject(%2); %}
	| MAP BRA TEXT KET 							%{ mMap(TU.text(%2)); %}
	| MDF BRA power_list KET BRA mdf_provinces KET BRA mdf_adjacencies KET %{ mMapDefinition(%2,%5,%8); %}
	| HLO BRA POWER KET BRA INTEGER KET BRA variant KET %{ mHello(TU.power(%2),TU.integer(%5),%8); %}
	| NOW BRA turn KET unit_with_location_and_mrt_list %{ mCurrentLocation(%2,%4); %}
	| SCO sco_entry_list 						%{ mSupplyOwnership(%1); %}
	| THX BRA order KET BRA order_note KET 		%{ mThink(%2,%5); %}
	| MIS unit_with_location_and_mrt_list 		%{ mMissingOrders(null,%1); %}
	| MIS BRA INTEGER KET 						%{ mMissingOrders(TU.integer(%2),null); %}
	| ORD BRA turn KET BRA order KET BRA compound_order_result KET %{ mOrderResult(%2,%5,%8); %}
	| SVE BRA TEXT KET 							%{ mSaveGame(TU.text(%2)); %}
	| LOD BRA TEXT KET 							%{ mLoadGame(TU.text(%2)); %}
	| OFF 										%{ mTurnOff; %}
	| TME BRA INTEGER KET 						%{ mTimeToDeadline(TU.integer(%2)); %}
	| PRN BRA bad_bracketed_sequence KET 		%{ mBadBrackets(%2); %}
	| HUH BRA any_token_sequence KET 			%{ mHuh(%2); %}
	| CCD BRA POWER KET 						%{ mPowerDisorder(TU.power(%2)); %}
	| NOT BRA negated_server_message KET 		%{ mNOT(%2); %}
	| ADM BRA TEXT KET BRA TEXT KET 			%{ mAdmin(TU.text(%2),TU.text(%5)); %}
	| SLO BRA INTEGER KET 						%{ mSolo(TU.integer(%2)); %}
	| DRW 										%{ mDraw(null); %}
	| OUT BRA POWER KET 						%{ mPowerEliminated(TU.power(%2)); %}
	| DRW BRA POWER power_list KET 				%{ %3.unshift(TU.power(%2)); mDraw(%3); %}
//	| FRM
//	| FRM
;

// Message
%acknowedgable_command
	: MAP BRA TEXT KET 			%{ mMap(TU.text(%2)); %}
	| SVE BRA TEXT KET 			%{ mSaveGame(TU.text(%2)); %}
;

// Message
%client_command
	: OBS 					%{ mObserver; %}
	| NOT BRA TME KET 		%{ mNOT(mTimeToDeadline(null)); %}
;

// Message
%client_request
	: NME BRA STRING KET BRA STRING KET 	%{ mName(TU.text(%2),TU.text(%5)); %}
	| IAM BRA POWER KET BRA INTEGER KET 	%{ mIAm(TU.power(%2),TU.integer(%5)); %}
	| NOT BRA GOF KET 						%{ mNOT(mGoFlag); %}
	| GOF 									%{ mGoFlag; %}
	| TME BRA INTEGER KET 					%{ mTimeToDeadline(TU.integer(%2)); %}
	| DRW 									%{ mDraw(null); %}
	| NOT BRA negated_client_request KET 	%{ mNOT(%2); %}
	| DRW BRA POWER power_list KET 			%{ %3.unshift(TU.power(%2)); mDraw(%3); %}
//	| send_message
;

// Message
%negated_client_request
	: TME BRA INTEGER KET 				%{ mTimeToDeadline(TU.integer(%2)); %}
	| DRW 								%{ mDraw(null); %}
	| DRW BRA POWER power_list KET 		%{ %3.unshift(TU.power(%2)); mDraw(%3); %}
;

// Message
%negated_server_message
	: TME BRA INTEGER KET 		%{ mTimeToDeadline(TU.integer(%2)); %}
	| CCD BRA POWER KET 		%{ mPowerDisorder(TU.power(%2)); %}
;

// Message
%rejectable_client_command
	: HLO 					%{ mHello(null,null,null); %}
	| NOW 					%{ mCurrentLocation(null,null); %}
	| SCO 					%{ mSupplyOwnership(null); %}
	| HST BRA turn KET 		%{ mHistory(%2); %}
	| SUB order_list 		%{ mSubmit(null,%1); %}
	| ORD 					%{ mOrderResult(null,null,null); %}
	| TME 					%{ mTimeToDeadline(null); %}
	| ADM BRA TEXT KET BRA TEXT KET %{ mAdmin(TU.text(%2),TU.text(%5)); %}
;

// Array<Token>
%any_token_sequence
	: any_no_braket %{ [%0]; %}
	| BRA any_token_sequence KET %{ %1.unshift(%0); %1.push(%2); %1; %}
	| any_token_sequence any_no_bracket %{ %0.push(%1); %0; %}
	| any_token_sequence BRA any_token_sequence KET %{ %0.push(%1); %0 = %0.concat(%2); %0.push(%3); %0; %}
;

%any_no_bracket : INTEGER | POWER | AMY | FLT | CTO | CVY | HLD | MTO | SUP | VIA | DSB | RTO | BLD | REM | WVE | MBV | BPR | CST | ESC | FAR | HSC | NAS | NMB | NMR | NRN | NRS | NSA | NSC | NSF | NSP | NST | NSU | NVR | NYU | YSC | SUC | BNC | CUT | DSR | FLD | NSO | RET | NCS | NEC | ECS | SEC | SCS | SWC | WCS | NWC | SPR | SUM | FAL | AUT | WIN | CCD | DRW | FRM | GOF | HLO | HST | HUH | IAM | LOD | MAP | MDF | MIS | NME | NOT | NOW | OBS | OFF | ORD | OUT | PRN | REJ | SCO | SLO | SND | SUB | SVE | THX | TME | YES | ADM | AOA | BTL | ERR | LVL | MRT | MTL | NPB | NPR | PDA | PTL | RTL | UNO | DSD | ALY | AND | BWD | DMZ | ELS | EXP | FWD | FCT | FOR | HOW | IDK | IFF | INS | IOU | OCC | ORR | PCE | POB | PPT | PRP | QRY | SCD | SRY | SUG | THK | THN | TRY | UOM | VSS | WHT | WHY | XDO | XOY | YDO | WRT | TEXT | INLAND | SEA | COASTAL | BICOASTAL ;

%any : any_no_bracket | BRA | KET ;

// Array<Token>
%bad_bracketed_sequence
	: any %{ [%0]; %}
	| bad_bracketed_sequence any %{ %0.push(%1); %0; %}
;

// Coast
%coast
	: NCS %{ TU.coast(%0); %} 
	| NEC %{ TU.coast(%0); %} 
	| ECS %{ TU.coast(%0); %} 
	| SEC %{ TU.coast(%0); %} 
	| SCS %{ TU.coast(%0); %} 
	| SWC %{ TU.coast(%0); %} 
	| WCS %{ TU.coast(%0); %} 
	| NWC %{ TU.coast(%0); %} 
;

// CompOrderResult
%compound_order_result
	: order_note %{ { note:%0, result:null, ret:false }; %}
	| order_result %{ { note:null, result:%0, ret:false }; %}
	| order_note RET %{ { note:%0, result:null, ret:true }; %}
	| order_result RET %{ { note:null, result:%0, ret:true }; %}
;

// ScoEntry
%sco_entry
	: POWER province_list %{ { power : TU.power(%0), locs : %1 }; %}
;

// Array<ScoEntry>
%sco_entry_list
	: BRA sco_entry KET %{ [%1]; %}
	| sco_entry_list BRA sco_entry KET %{ %0.push(%2); %0; %}
;

// Turn
%turn
	: phase INTEGER %{ { phase : %0, turn : TU.integer(%1) }; %} 
;

// Phase
%phase
	: SPR %{ TU.phase(%0); %} 
	| SUM %{ TU.phase(%0); %} 
	| FAL %{ TU.phase(%0); %} 
	| AUT %{ TU.phase(%0); %} 
	| WIN %{ TU.phase(%0); %} 
;

// Province
%province
	: INLAND %{ TU.province(%0); %}
	| SEA %{ TU.province(%0); %}
	| COASTAL %{ TU.province(%0); %}
	| BICOASTAL %{ TU.province(%0); %}
;

// Array<Int>
%power_list
	: POWER %{ [TU.power(%0)]; %}
	| power_list POWER %{ %0.push(TU.power(%1)); %0; %}
;

// MsgOrder
%order
	: BRA unit_with_location KET HLD %{ moHold(%1); %}
	| BRA unit_with_location KET DSB %{ moDisband(%1); %}
	| BRA unit_with_location KET BLD %{ moBuild(%1); %}
	| BRA unit_with_location KET REM %{ moRemove(%1); %}
	| BRA unit_with_location KET RTO mdf_province %{ moRetreat(%1,%4); %}
	| BRA unit_with_location KET MTO mdf_province %{ moMove(%1,%4); %}
	| BRA unit_with_location KET SUP BRA unit_with_location KET %{
		moSupport(%1,%5,null);
	%}
	| BRA unit_with_location KET SUP BRA unit_with_location KET MTO province %{
		moSupport(%1,%5,%8);
	%}
	| BRA unit_with_location KET CVY BRA unit_with_location KET CTO province %{
		moConvoy(%1,%5,%8);
	%}
	| BRA unit_with_location KET CTO province VIA BRA province_list KET %{
		moMoveByConvoy(%1,%4,%7);
	%}
;

// Array<MsgOrder>
%order_list
	: BRA order KET %{ [%1]; %}
	| order_list BRA order KET %{ %0.push(%2); %0; %}
;

// OrderNote
%order_note : sub_order_note %{ switch(cast(%0,Token)) { case tOrderNote(x): x; default : null; } %} ;
%sub_order_note : MBV | FAR | NSP | NSU | NAS | NSF | NSA | NYU | NRN | NVR | YSC | ESC | HSC | NSC | CST | NMB | NMR | NRS ;

// Result
%order_result : sub_order_result %{ switch(cast(%0,Token)) { case tResult(x): x; default : null; } %} ;
%sub_order_result : SUC | BNC | CUT | DSR | NSO ;

// UnitWithLoc
%unit_with_location
	: POWER unit_type mdf_province %{ { power : TU.power(%0), type : %1, location : %2 }; %}
;

// Array<MdfProAdjacencies>
%mdf_adjacencies
	: BRA mdf_province_adjacencies KET %{ [%1]; %}
	| mdf_provinces BRA mdf_province_adjacencies KET %{ %0.push(%2); %0; %}
;

// MdfProAdjacencies
%mdf_province_adjacencies
	: province mdf_coast_adjacencies_list %{ { pro : %0, coasts : %1 }; %}
;

// Coast
%mdf_coast
	: FLT coast %{ %1; %}
;

// MdfCoastAdjacencies
%mdf_coast_adjacencies
	: unit_type mdf_province_list %{ { unit : %0, locs : %1 }; %}
;

// Array<MdfCoastAdjacencies>
%mdf_coast_adjacencies_list
	: BRA mdf_coast_adjacencies KET %{ [%1]; %}
	| mdf_coast_adjacencies_list BRA mdf_coast_adjacencies KET %{ %0.push(%2); %0; %}
;

// MdfCentreList
%mdf_centre_list
	: POWER province_list %{ { powers: [TU.power(%0)], locs : %1 }; %}
	| UNO province_list   %{ { powers: [], locs : %1 }; %}
	| BRA power_list KET province_list %{ { powers: %1, locs : %3 }; %}
;

// Array<MdfCentreList>
%mdf_supply_centres
	: BRA mdf_centre_list KET %{ [%1]; %}
	| mdf_centre_list_list BRA mdf_centre_list KET %{ %0.push(%2); %0; %}
;

// MdfProvinces
%mdf_provinces
	: BRA mdf_supply_centres KET BRA province_list KET %{ {slocs: %2, locs : %4 }; %}
;

// Location
%mdf_province
	: province %{ { province : %0, coast : null }; %}
	| BRA province_and_coast KET %{ %1; %}
;

// Array<Location>
%mdf_province_list
	: mdf_province %{ [%0]; %}
	| mdf_province_list mdf_province %{ %0.push(%1); %0; %}
;

// Message
%negatable_command
	: SUB BRA order KET %{ mSubmit(null,cast [%2]); %}
	| SUB %{ mSubmit(null,null); %}
	| GOF %{ mGoFlag; %}
	| DRW %{ mDraw(null); %}
	| DRW BRA POWER power_list KET %{ %3.unshift(TU.power(%2)); mDraw(%3); %}
	| TME %{ mTimeToDeadline(null); %}
	| TME BRA INTEGER KET %{ mTimeToDeadline(TU.integer(%2)); %}
;

// Location
%province_and_coast
	: province coast %{ { province : %0, coast : %1 }; %}
;

// Array<Location>
%province_list
	: province %{ [%0]; %}
	| province_list province %{ %0.push(%1); %0; %}
;

// UnitType
%unit_type
	: AMY %{ TU.unitType(%0); %}
	| FLT %{ TU.unitType(%0); %}
;

// UnitWithLocAndMRT
%unit_with_location_and_mrt
	: unit_with_location %{ { unitloc : %0, locs : null }; %}
	| unit_with_location MRT BRA mdf_province_list KET %{ { unitloc : %0, locs : %3 }; %}
;

// Array<UnitWithLocAndMRT>
%unit_with_location_and_mrt_list
	: BRA unit_with_location_and_mrt KET %{ [%1]; %}
	| unit_with_location_and_mrt_list BRA unit_with_location_and_mrt KET %{ %0.push(%2); %0; %}
;

// Variant
%variant
	: BRA variant_option KET %{ [%1]; %}
	| variant BRA variant_option KET %{ %0.push(%2); %0; %}
;

// VariantOption
%variant_option
	: LVL INTEGER %{ { par : TU.parameter(%0), val : TU.integer(%1) }; %}
	| MTL INTEGER %{ { par : TU.parameter(%0), val : TU.integer(%1) }; %}
	| RTL INTEGER %{ { par : TU.parameter(%0), val : TU.integer(%1) }; %}
	| BTL INTEGER %{ { par : TU.parameter(%0), val : TU.integer(%1) }; %}
	| AOA         %{ { par : TU.parameter(%0), val : null           }; %}
	| DSD         %{ { par : TU.parameter(%0), val : null           }; %}
	| PDA         %{ { par : TU.parameter(%0), val : null           }; %}
	| PTL INTEGER %{ { par : TU.parameter(%0), val : TU.integer(%1) }; %}
	| NPR         %{ { par : TU.parameter(%0), val : null           }; %}
	| NPB         %{ { par : TU.parameter(%0), val : null           }; %}
;
